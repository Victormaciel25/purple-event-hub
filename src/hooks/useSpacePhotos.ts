
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";
import type { SpacePhoto } from "@/types/approval";

export const useSpacePhotos = (spaceId: string | null) => {
  const [photos, setPhotos] = useState<SpacePhoto[]>([]);
  const [photoUrls, setPhotoUrls] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);

  const fetchPhotos = async (id: string) => {
    try {
      setLoading(true);
      console.log("üîç INICIANDO busca de fotos/v√≠deos para espa√ßo:", id);

      // Limpar estado anterior
      setPhotos([]);
      setPhotoUrls([]);

      // Buscar fotos diretamente da tabela space_photos
      const { data: photosData, error } = await supabase
        .from('space_photos')
        .select('*')
        .eq('space_id', id)
        .order('created_at', { ascending: true });

      if (error) {
        console.error("‚ùå Erro ao buscar fotos:", error);
        toast.error("Erro ao buscar fotos");
        return;
      }

      console.log("üì∏ DADOS BRUTOS encontrados:", photosData?.length || 0);
      console.log("üìã TODOS os dados das m√≠dias:", photosData);
      
      // SEMPRE buscar arquivos diretamente do bucket para garantir que n√£o percamos nada
      const bucketFiles = await fetchFromBucket(id);
      
      if (photosData && photosData.length > 0) {
        // Log detalhado de cada m√≠dia ANTES de qualquer processamento
        photosData.forEach((photo, index) => {
          console.log(`üìÅ AN√ÅLISE COMPLETA M√≠dia ${index + 1}:`, {
            id: photo.id,
            storage_path: photo.storage_path,
            created_at: photo.created_at,
            pathAnalysis: {
              fullPath: photo.storage_path,
              isURL: photo.storage_path?.startsWith('http'),
              containsVideo: photo.storage_path?.toLowerCase().includes('video'),
              extension: photo.storage_path?.split('.').pop()?.toLowerCase(),
              fileName: photo.storage_path?.split('/').pop(),
              hasVideoExt: ['.mp4', '.webm', '.mov', '.avi'].some(ext => 
                photo.storage_path?.toLowerCase().includes(ext)
              )
            }
          });
        });

        // Fun√ß√£o de detec√ß√£o de v√≠deo MELHORADA
        const isVideoFile = (storagePath: string) => {
          if (!storagePath) return false;
          
          const path = storagePath.toLowerCase();
          const fileName = storagePath.split('/').pop()?.toLowerCase() || '';
          const extension = fileName.split('.').pop() || '';
          
          console.log(`üé¨ DETEC√á√ÉO DE V√çDEO DETALHADA para: ${storagePath}`, {
            path,
            fileName,
            extension,
            checks: {
              hasVideoExtension: ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.m4v'].includes(`.${extension}`),
              pathContainsVideo: path.includes('video'),
              fileNameContainsVideo: fileName.includes('video'),
              isMP4: extension === 'mp4' || path.includes('.mp4'),
              isWebM: extension === 'webm' || path.includes('.webm'),
              isMOV: extension === 'mov' || path.includes('.mov')
            }
          });
          
          const videoExtensions = ['mp4', 'webm', 'mov', 'avi', 'mkv', 'm4v'];
          const isVideo = videoExtensions.includes(extension) || 
                         path.includes('video') ||
                         videoExtensions.some(ext => path.includes(`.${ext}`));
          
          console.log(`üéØ RESULTADO DETEC√á√ÉO: ${storagePath} -> ${isVideo ? 'V√çDEO' : 'IMAGEM'}`);
          return isVideo;
        };

        // Classificar m√≠dias da tabela
        const videosFromTable = photosData.filter(p => isVideoFile(p.storage_path));
        const imagesFromTable = photosData.filter(p => !isVideoFile(p.storage_path));
        
        console.log("üìä CLASSIFICA√á√ÉO DA TABELA:", {
          total: photosData.length,
          videos: videosFromTable.length,
          images: imagesFromTable.length,
          videoList: videosFromTable.map(v => ({ id: v.id, path: v.storage_path })),
          imageList: imagesFromTable.map(i => ({ id: i.id, path: i.storage_path }))
        });

        // Combinar dados da tabela com dados do bucket
        const allPhotos = [...photosData];
        
        // Adicionar arquivos do bucket que n√£o est√£o na tabela
        bucketFiles.forEach(bucketFile => {
          const existsInTable = photosData.some(p => 
            p.storage_path === bucketFile.storage_path || 
            p.storage_path.includes(bucketFile.fileName)
          );
          
          if (!existsInTable) {
            console.log("üî• ADICIONANDO arquivo do bucket que n√£o est√° na tabela:", bucketFile);
            allPhotos.push({
              id: `bucket-${bucketFile.fileName}`,
              space_id: id,
              storage_path: bucketFile.storage_path,
              created_at: new Date().toISOString()
            });
          }
        });

        // Reclassificar com todos os arquivos
        const videos = allPhotos.filter(p => isVideoFile(p.storage_path));
        const images = allPhotos.filter(p => !isVideoFile(p.storage_path));
        
        console.log("üìä CLASSIFICA√á√ÉO FINAL (TABELA + BUCKET):", {
          total: allPhotos.length,
          videos: videos.length,
          images: images.length,
          videoList: videos.map(v => ({ id: v.id, path: v.storage_path })),
          imageList: images.map(i => ({ id: i.id, path: i.storage_path }))
        });

        // Ordenar: imagens primeiro, v√≠deos por √∫ltimo
        const sortedPhotos = [...images, ...videos];
        
        console.log("üéØ M√çDIAS ORDENADAS:", sortedPhotos.map(p => ({
          id: p.id,
          path: p.storage_path,
          isVideo: isVideoFile(p.storage_path)
        })));
        
        setPhotos(sortedPhotos);
        await createPhotoUrls(sortedPhotos);
        
      } else {
        console.log("‚ö†Ô∏è NENHUMA foto/v√≠deo encontrado na tabela para o espa√ßo");
        
        // Se n√£o h√° dados na tabela, usar apenas os arquivos do bucket
        if (bucketFiles.length > 0) {
          console.log("üî• USANDO APENAS ARQUIVOS DO BUCKET:", bucketFiles);
          
          const bucketPhotos = bucketFiles.map(file => ({
            id: `bucket-${file.fileName}`,
            space_id: id,
            storage_path: file.storage_path,
            created_at: new Date().toISOString()
          }));
          
          setPhotos(bucketPhotos);
          await createPhotoUrls(bucketPhotos);
          
          toast.success(`${bucketFiles.length} arquivo(s) encontrado(s) diretamente no storage!`);
        }
      }
    } catch (error) {
      console.error("üí• ERRO GERAL ao buscar fotos:", error);
      toast.error("Erro ao carregar fotos");
      setPhotoUrls([]);
    } finally {
      setLoading(false);
    }
  };

  // Nova fun√ß√£o para buscar arquivos diretamente do bucket
  const fetchFromBucket = async (spaceId: string) => {
    const foundFiles: Array<{fileName: string, storage_path: string}> = [];
    
    try {
      console.log("üîç BUSCANDO ARQUIVOS DIRETAMENTE NO BUCKET para espa√ßo:", spaceId);
      
      // Buscar na pasta spaces (onde est√£o os arquivos reais)
      const { data: files, error } = await supabase.storage
        .from('spaces')
        .list('spaces', { limit: 1000 });
      
      if (!error && files && files.length > 0) {
        console.log(`üìÇ ARQUIVOS ENCONTRADOS na pasta 'spaces':`, files.length);
        
        // Filtrar arquivos de m√≠dia (imagens e v√≠deos)
        const mediaFiles = files.filter(file => {
          const ext = file.name.split('.').pop()?.toLowerCase();
          return ['jpg', 'jpeg', 'png', 'gif', 'webp', 'mp4', 'webm', 'mov', 'avi'].includes(ext || '');
        });
        
        console.log(`üé¨ ARQUIVOS DE M√çDIA encontrados:`, mediaFiles);
        
        mediaFiles.forEach(file => {
          const fullPath = `spaces/${file.name}`;
          const { data } = supabase.storage.from('spaces').getPublicUrl(fullPath);
          
          foundFiles.push({
            fileName: file.name,
            storage_path: data.publicUrl
          });
          
          console.log(`üìÅ ARQUIVO PROCESSADO:`, {
            name: file.name,
            fullPath,
            publicUrl: data.publicUrl
          });
        });
      }
      
      console.log("üîó TOTAL DE ARQUIVOS ENCONTRADOS NO BUCKET:", foundFiles.length);
      return foundFiles;
      
    } catch (error) {
      console.error("‚ùå Erro ao buscar arquivos no bucket:", error);
      return [];
    }
  };

  const createPhotoUrls = async (photosData: SpacePhoto[]) => {
    try {
      console.log("üîó CRIANDO URLs para", photosData.length, "fotos/v√≠deos");
      
      const urls = await Promise.all(
        photosData.map(async (photo, index) => {
          if (!photo.storage_path) {
            console.error("‚ùå CAMINHO AUSENTE para m√≠dia:", photo.id);
            return null;
          }

          console.log(`üîÑ PROCESSANDO m√≠dia ${index + 1}:`, {
            id: photo.id,
            storage_path: photo.storage_path,
            isFullURL: photo.storage_path.startsWith('http')
          });

          // Se j√° √© uma URL completa, usar diretamente
          if (photo.storage_path.startsWith('http')) {
            console.log("‚úÖ J√Å √â URL COMPLETA:", photo.storage_path);
            return photo.storage_path;
          }

          // Tentar criar URL a partir do storage path
          try {
            const { data: publicUrlData } = supabase.storage
              .from('spaces')
              .getPublicUrl(photo.storage_path);
            
            if (publicUrlData?.publicUrl) {
              console.log(`‚úÖ URL P√öBLICA criada:`, {
                originalPath: photo.storage_path,
                url: publicUrlData.publicUrl
              });
              return publicUrlData.publicUrl;
            }
          } catch (urlError) {
            console.error("‚ùå ERRO ao criar URL:", urlError);
          }

          console.error(`‚ùå FALHA TOTAL para m√≠dia:`, photo.storage_path);
          return null;
        })
      );

      const validUrls = urls.filter(url => url !== null) as string[];
      
      console.log("‚ú® RESUMO FINAL COMPLETO:");
      console.log("- URLs v√°lidas criadas:", validUrls.length, "de", photosData.length, "m√≠dias");
      console.log("- TODAS as URLs v√°lidas:", validUrls);
      
      setPhotoUrls(validUrls);
    } catch (error) {
      console.error("üí• ERRO FATAL ao criar URLs das m√≠dias:", error);
      setPhotoUrls([]);
    }
  };

  // Force refresh quando spaceId muda
  useEffect(() => {
    if (spaceId) {
      console.log("üîÑ useSpacePhotos - spaceId mudou para:", spaceId);
      const timer = setTimeout(() => {
        fetchPhotos(spaceId);
      }, 100);
      
      return () => clearTimeout(timer);
    } else {
      console.log("üßπ useSpacePhotos - spaceId √© null, limpando fotos");
      setPhotos([]);
      setPhotoUrls([]);
    }
  }, [spaceId]);

  return {
    photos,
    photoUrls,
    loading,
    refetch: () => {
      if (spaceId) {
        console.log("üîÑ REFETCH MANUAL das fotos para espa√ßo:", spaceId);
        fetchPhotos(spaceId);
      }
    }
  };
};
